(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("nipplejs", [], factory);
	else if(typeof exports === 'object')
		exports["nipplejs"] = factory();
	else
		root["nipplejs"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/collection.js":
/*!***************************!*\
  !*** ./src/collection.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _nipple__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nipple */ \"./src/nipple.js\");\n/* harmony import */ var _super__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./super */ \"./src/super.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\n\n ///////////////////////////\n///   THE COLLECTION    ///\n///////////////////////////\n\nfunction Collection(manager, options) {\n  var self = this;\n  self.nipples = [];\n  self.idles = [];\n  self.actives = [];\n  self.ids = [];\n  self.pressureIntervals = {};\n  self.manager = manager;\n  self.id = Collection.id;\n  Collection.id += 1; // Defaults\n\n  self.defaults = {\n    zone: document.body,\n    multitouch: false,\n    maxNumberOfNipples: 10,\n    mode: 'dynamic',\n    position: {\n      top: 0,\n      left: 0\n    },\n    catchDistance: 200,\n    size: 100,\n    threshold: 0.1,\n    color: 'white',\n    fadeTime: 250,\n    dataOnly: false,\n    restJoystick: true,\n    restOpacity: 0.5,\n    lockX: false,\n    lockY: false,\n    shape: 'circle',\n    dynamicPage: false,\n    follow: false\n  };\n  self.config(options); // Overwrites\n\n  if (self.options.mode === 'static' || self.options.mode === 'semi') {\n    self.options.multitouch = false;\n  }\n\n  if (!self.options.multitouch) {\n    self.options.maxNumberOfNipples = 1;\n  }\n\n  var computedStyle = getComputedStyle(self.options.zone.parentElement);\n\n  if (computedStyle && computedStyle.display === 'flex') {\n    self.parentIsFlex = true;\n  }\n\n  self.updateBox();\n  self.prepareNipples();\n  self.bindings();\n  self.begin();\n  return self.nipples;\n}\n\nCollection.prototype = new _super__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\nCollection.constructor = Collection;\nCollection.id = 0;\n\nCollection.prototype.prepareNipples = function () {\n  var self = this;\n  var nips = self.nipples; // Public API Preparation.\n\n  nips.on = self.on.bind(self);\n  nips.off = self.off.bind(self);\n  nips.options = self.options;\n  nips.destroy = self.destroy.bind(self);\n  nips.ids = self.ids;\n  nips.id = self.id;\n  nips.processOnMove = self.processOnMove.bind(self);\n  nips.processOnEnd = self.processOnEnd.bind(self);\n\n  nips.get = function (id) {\n    if (id === undefined) {\n      return nips[0];\n    }\n\n    for (var i = 0, max = nips.length; i < max; i += 1) {\n      if (nips[i].identifier === id) {\n        return nips[i];\n      }\n    }\n\n    return false;\n  };\n};\n\nCollection.prototype.bindings = function () {\n  var self = this; // Touch start event.\n\n  self.bindEvt(self.options.zone, 'start'); // Avoid native touch actions (scroll, zoom etc...) on the zone.\n\n  self.options.zone.style.touchAction = 'none';\n  self.options.zone.style.msTouchAction = 'none';\n};\n\nCollection.prototype.begin = function () {\n  var self = this;\n  var opts = self.options; // We place our static nipple\n  // if needed.\n\n  if (opts.mode === 'static') {\n    var nipple = self.createNipple(opts.position, self.manager.getIdentifier()); // Add it to the dom.\n\n    nipple.add(); // Store it in idles.\n\n    self.idles.push(nipple);\n  }\n}; // Nipple Factory\n\n\nCollection.prototype.createNipple = function (position, identifier) {\n  var self = this;\n  var scroll = self.manager.scroll;\n  var toPutOn = {};\n  var opts = self.options;\n  var offset = {\n    x: self.parentIsFlex ? scroll.x : scroll.x + self.box.left,\n    y: self.parentIsFlex ? scroll.y : scroll.y + self.box.top\n  };\n\n  if (position.x && position.y) {\n    toPutOn = {\n      x: position.x - offset.x,\n      y: position.y - offset.y\n    };\n  } else if (position.top || position.right || position.bottom || position.left) {\n    // We need to compute the position X / Y of the joystick.\n    var dumb = document.createElement('DIV');\n    dumb.style.display = 'hidden';\n    dumb.style.top = position.top;\n    dumb.style.right = position.right;\n    dumb.style.bottom = position.bottom;\n    dumb.style.left = position.left;\n    dumb.style.position = 'absolute';\n    opts.zone.appendChild(dumb);\n    var dumbBox = dumb.getBoundingClientRect();\n    opts.zone.removeChild(dumb);\n    toPutOn = position;\n    position = {\n      x: dumbBox.left + scroll.x,\n      y: dumbBox.top + scroll.y\n    };\n  }\n\n  var nipple = new _nipple__WEBPACK_IMPORTED_MODULE_0__[\"default\"](self, {\n    color: opts.color,\n    size: opts.size,\n    threshold: opts.threshold,\n    fadeTime: opts.fadeTime,\n    dataOnly: opts.dataOnly,\n    restJoystick: opts.restJoystick,\n    restOpacity: opts.restOpacity,\n    mode: opts.mode,\n    identifier: identifier,\n    position: position,\n    zone: opts.zone,\n    frontPosition: {\n      x: 0,\n      y: 0\n    },\n    shape: opts.shape\n  });\n\n  if (!opts.dataOnly) {\n    _utils__WEBPACK_IMPORTED_MODULE_2__[\"applyPosition\"](nipple.ui.el, toPutOn);\n    _utils__WEBPACK_IMPORTED_MODULE_2__[\"applyPosition\"](nipple.ui.front, nipple.frontPosition);\n  }\n\n  self.nipples.push(nipple);\n  self.trigger('added ' + nipple.identifier + ':added', nipple);\n  self.manager.trigger('added ' + nipple.identifier + ':added', nipple);\n  self.bindNipple(nipple);\n  return nipple;\n};\n\nCollection.prototype.updateBox = function () {\n  var self = this;\n  self.box = self.options.zone.getBoundingClientRect();\n};\n\nCollection.prototype.bindNipple = function (nipple) {\n  var self = this;\n  var type; // Bubble up identified events.\n\n  var handler = function handler(evt, data) {\n    // Identify the event type with the nipple's id.\n    type = evt.type + ' ' + data.id + ':' + evt.type;\n    self.trigger(type, data);\n  }; // When it gets destroyed.\n\n\n  nipple.on('destroyed', self.onDestroyed.bind(self)); // Other events that will get bubbled up.\n\n  nipple.on('shown hidden rested dir plain', handler);\n  nipple.on('dir:up dir:right dir:down dir:left', handler);\n  nipple.on('plain:up plain:right plain:down plain:left', handler);\n};\n\nCollection.prototype.pressureFn = function (touch, nipple, identifier) {\n  var self = this;\n  var previousPressure = 0;\n  clearInterval(self.pressureIntervals[identifier]); // Create an interval that will read the pressure every 100ms\n\n  self.pressureIntervals[identifier] = setInterval(function () {\n    var pressure = touch.force || touch.pressure || touch.webkitForce || 0;\n\n    if (pressure !== previousPressure) {\n      nipple.trigger('pressure', pressure);\n      self.trigger('pressure ' + nipple.identifier + ':pressure', pressure);\n      previousPressure = pressure;\n    }\n  }.bind(self), 100);\n};\n\nCollection.prototype.onstart = function (evt) {\n  var self = this;\n  var opts = self.options;\n  var origEvt = evt;\n  evt = _utils__WEBPACK_IMPORTED_MODULE_2__[\"prepareEvent\"](evt); // Update the box position\n\n  self.updateBox();\n\n  var process = function process(touch) {\n    // If we can create new nipples\n    // meaning we don't have more active nipples than we should.\n    if (self.actives.length < opts.maxNumberOfNipples) {\n      self.processOnStart(touch);\n    } else if (origEvt.type.match(/^touch/)) {\n      // zombies occur when end event is not received on Safari\n      // first touch removed before second touch, we need to catch up...\n      // so remove where touches in manager that no longer exist\n      Object.keys(self.manager.ids).forEach(function (k) {\n        if (Object.values(origEvt.touches).findIndex(function (t) {\n          return t.identifier === k;\n        }) < 0) {\n          // manager has id that doesn't exist in touches\n          var e = [evt[0]];\n          e.identifier = k;\n          self.processOnEnd(e);\n        }\n      });\n\n      if (self.actives.length < opts.maxNumberOfNipples) {\n        self.processOnStart(touch);\n      }\n    }\n  };\n\n  _utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"](evt, process); // We ask upstream to bind the document\n  // on 'move' and 'end'\n\n  self.manager.bindDocument();\n  return false;\n};\n\nCollection.prototype.processOnStart = function (evt) {\n  var self = this;\n  var opts = self.options;\n  var indexInIdles;\n  var identifier = self.manager.getIdentifier(evt);\n  var pressure = evt.force || evt.pressure || evt.webkitForce || 0;\n  var position = {\n    x: evt.pageX,\n    y: evt.pageY\n  };\n  var nipple = self.getOrCreate(identifier, position); // Update its touch identifier\n\n  if (nipple.identifier !== identifier) {\n    self.manager.removeIdentifier(nipple.identifier);\n  }\n\n  nipple.identifier = identifier;\n\n  var process = function process(nip) {\n    // Trigger the start.\n    nip.trigger('start', nip);\n    self.trigger('start ' + nip.id + ':start', nip);\n    nip.show();\n\n    if (pressure > 0) {\n      self.pressureFn(evt, nip, nip.identifier);\n    } // Trigger the first move event.\n\n\n    self.processOnMove(evt);\n  }; // Transfer it from idles to actives.\n\n\n  if ((indexInIdles = self.idles.indexOf(nipple)) >= 0) {\n    self.idles.splice(indexInIdles, 1);\n  } // Store the nipple in the actives array\n\n\n  self.actives.push(nipple);\n  self.ids.push(nipple.identifier);\n\n  if (opts.mode !== 'semi') {\n    process(nipple);\n  } else {\n    // In semi we check the distance of the touch\n    // to decide if we have to reset the nipple\n    var distance = _utils__WEBPACK_IMPORTED_MODULE_2__[\"distance\"](position, nipple.position);\n\n    if (distance <= opts.catchDistance) {\n      process(nipple);\n    } else {\n      nipple.destroy();\n      self.processOnStart(evt);\n      return;\n    }\n  }\n\n  return nipple;\n};\n\nCollection.prototype.getOrCreate = function (identifier, position) {\n  var self = this;\n  var opts = self.options;\n  var nipple; // If we're in static or semi, we might already have an active.\n\n  if (/(semi|static)/.test(opts.mode)) {\n    // Get the active one.\n    // TODO: Multi-touche for semi and static will start here.\n    // Return the nearest one.\n    nipple = self.idles[0];\n\n    if (nipple) {\n      self.idles.splice(0, 1);\n      return nipple;\n    }\n\n    if (opts.mode === 'semi') {\n      // If we're in semi mode, we need to create one.\n      return self.createNipple(position, identifier);\n    } // eslint-disable-next-line no-console\n\n\n    console.warn('Coudln\\'t find the needed nipple.');\n    return false;\n  } // In dynamic, we create a new one.\n\n\n  nipple = self.createNipple(position, identifier);\n  return nipple;\n};\n\nCollection.prototype.processOnMove = function (evt) {\n  var self = this;\n  var opts = self.options;\n  var identifier = self.manager.getIdentifier(evt);\n  var nipple = self.nipples.get(identifier);\n  var scroll = self.manager.scroll; // If we're moving without pressing\n  // it's that we went out the active zone\n\n  if (!_utils__WEBPACK_IMPORTED_MODULE_2__[\"isPressed\"](evt)) {\n    this.processOnEnd(evt);\n    return;\n  }\n\n  if (!nipple) {\n    // This is here just for safety.\n    // It shouldn't happen.\n    // eslint-disable-next-line no-console\n    console.error('Found zombie joystick with ID ' + identifier);\n    self.manager.removeIdentifier(identifier);\n    return;\n  }\n\n  if (opts.dynamicPage) {\n    var elBox = nipple.el.getBoundingClientRect();\n    nipple.position = {\n      x: scroll.x + elBox.left,\n      y: scroll.y + elBox.top\n    };\n  }\n\n  nipple.identifier = identifier;\n  var size = nipple.options.size / 2;\n  var pos = {\n    x: evt.pageX,\n    y: evt.pageY\n  };\n\n  if (opts.lockX) {\n    pos.y = nipple.position.y;\n  }\n\n  if (opts.lockY) {\n    pos.x = nipple.position.x;\n  }\n\n  var dist = _utils__WEBPACK_IMPORTED_MODULE_2__[\"distance\"](pos, nipple.position);\n  var angle = _utils__WEBPACK_IMPORTED_MODULE_2__[\"angle\"](pos, nipple.position);\n  var rAngle = _utils__WEBPACK_IMPORTED_MODULE_2__[\"radians\"](angle);\n  var force = dist / size;\n  var raw = {\n    distance: dist,\n    position: pos\n  }; // Clamp the position\n\n  var clamped_dist;\n  var clamped_pos;\n\n  if (nipple.options.shape === 'circle') {\n    // Clamp to a circle\n    clamped_dist = Math.min(dist, size);\n    clamped_pos = _utils__WEBPACK_IMPORTED_MODULE_2__[\"findCoord\"](nipple.position, clamped_dist, angle);\n  } else {\n    // Clamp to a square\n    clamped_pos = _utils__WEBPACK_IMPORTED_MODULE_2__[\"clamp\"](pos, nipple.position, size);\n    clamped_dist = _utils__WEBPACK_IMPORTED_MODULE_2__[\"distance\"](clamped_pos, nipple.position);\n  }\n\n  if (opts.follow) {\n    // follow behaviour\n    if (dist > size) {\n      var delta_x = pos.x - clamped_pos.x;\n      var delta_y = pos.y - clamped_pos.y;\n      nipple.position.x += delta_x;\n      nipple.position.y += delta_y;\n      nipple.el.style.top = nipple.position.y - (self.box.top + scroll.y) + 'px';\n      nipple.el.style.left = nipple.position.x - (self.box.left + scroll.x) + 'px';\n      dist = _utils__WEBPACK_IMPORTED_MODULE_2__[\"distance\"](pos, nipple.position);\n    }\n  } else {\n    // clamp behaviour\n    pos = clamped_pos;\n    dist = clamped_dist;\n  }\n\n  var xPosition = pos.x - nipple.position.x;\n  var yPosition = pos.y - nipple.position.y;\n  nipple.frontPosition = {\n    x: xPosition,\n    y: yPosition\n  };\n\n  if (!opts.dataOnly) {\n    nipple.ui.front.style.transform = 'translate(' + xPosition + 'px,' + yPosition + 'px)';\n  } // Prepare event's datas.\n\n\n  var toSend = {\n    identifier: nipple.identifier,\n    position: pos,\n    force: force,\n    pressure: evt.force || evt.pressure || evt.webkitForce || 0,\n    distance: dist,\n    angle: {\n      radian: rAngle,\n      degree: angle\n    },\n    vector: {\n      x: xPosition / size,\n      y: -yPosition / size\n    },\n    raw: raw,\n    instance: nipple,\n    lockX: opts.lockX,\n    lockY: opts.lockY\n  }; // Compute the direction's datas.\n\n  toSend = nipple.computeDirection(toSend); // Offset angles to follow units circle.\n\n  toSend.angle = {\n    radian: _utils__WEBPACK_IMPORTED_MODULE_2__[\"radians\"](180 - angle),\n    degree: 180 - angle\n  }; // Send everything to everyone.\n\n  nipple.trigger('move', toSend);\n  self.trigger('move ' + nipple.id + ':move', toSend);\n};\n\nCollection.prototype.processOnEnd = function (evt) {\n  var self = this;\n  var opts = self.options;\n  var identifier = self.manager.getIdentifier(evt);\n  var nipple = self.nipples.get(identifier);\n  var removedIdentifier = self.manager.removeIdentifier(nipple.identifier);\n\n  if (!nipple) {\n    return;\n  }\n\n  if (!opts.dataOnly) {\n    nipple.hide(function () {\n      if (opts.mode === 'dynamic') {\n        nipple.trigger('removed', nipple);\n        self.trigger('removed ' + nipple.id + ':removed', nipple);\n        self.manager.trigger('removed ' + nipple.id + ':removed', nipple);\n        nipple.destroy();\n      }\n    });\n  } // Clear the pressure interval reader\n\n\n  clearInterval(self.pressureIntervals[nipple.identifier]); // Reset the direciton of the nipple, to be able to trigger a new direction\n  // on start.\n\n  nipple.resetDirection();\n  nipple.trigger('end', nipple);\n  self.trigger('end ' + nipple.id + ':end', nipple); // Remove identifier from our bank.\n\n  if (self.ids.indexOf(nipple.identifier) >= 0) {\n    self.ids.splice(self.ids.indexOf(nipple.identifier), 1);\n  } // Clean our actives array.\n\n\n  if (self.actives.indexOf(nipple) >= 0) {\n    self.actives.splice(self.actives.indexOf(nipple), 1);\n  }\n\n  if (/(semi|static)/.test(opts.mode)) {\n    // Transfer nipple from actives to idles\n    // if we're in semi or static mode.\n    self.idles.push(nipple);\n  } else if (self.nipples.indexOf(nipple) >= 0) {\n    // Only if we're not in semi or static mode\n    // we can remove the instance.\n    self.nipples.splice(self.nipples.indexOf(nipple), 1);\n  } // We unbind move and end.\n\n\n  self.manager.unbindDocument(); // We add back the identifier of the idle nipple;\n\n  if (/(semi|static)/.test(opts.mode)) {\n    self.manager.ids[removedIdentifier.id] = removedIdentifier.identifier;\n  }\n}; // Remove destroyed nipple from the lists\n\n\nCollection.prototype.onDestroyed = function (evt, nipple) {\n  var self = this;\n\n  if (self.nipples.indexOf(nipple) >= 0) {\n    self.nipples.splice(self.nipples.indexOf(nipple), 1);\n  }\n\n  if (self.actives.indexOf(nipple) >= 0) {\n    self.actives.splice(self.actives.indexOf(nipple), 1);\n  }\n\n  if (self.idles.indexOf(nipple) >= 0) {\n    self.idles.splice(self.idles.indexOf(nipple), 1);\n  }\n\n  if (self.ids.indexOf(nipple.identifier) >= 0) {\n    self.ids.splice(self.ids.indexOf(nipple.identifier), 1);\n  } // Remove the identifier from our bank\n\n\n  self.manager.removeIdentifier(nipple.identifier); // We unbind move and end.\n\n  self.manager.unbindDocument();\n}; // Cleanly destroy the manager\n\n\nCollection.prototype.destroy = function () {\n  var self = this;\n  self.unbindEvt(self.options.zone, 'start'); // Destroy nipples.\n\n  self.nipples.forEach(function (nipple) {\n    nipple.destroy();\n  }); // Clean 3DTouch intervals.\n\n  for (var i in self.pressureIntervals) {\n    if (self.pressureIntervals.hasOwnProperty(i)) {\n      clearInterval(self.pressureIntervals[i]);\n    }\n  } // Notify the manager passing the instance\n\n\n  self.trigger('destroyed', self.nipples); // We unbind move and end.\n\n  self.manager.unbindDocument(); // Unbind everything.\n\n  self.off();\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Collection);\n\n//# sourceURL=webpack://nipplejs/./src/collection.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./manager */ \"./src/manager.js\");\n\nvar factory = new _manager__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  create: function create(options) {\n    return factory.create(options);\n  },\n  factory: factory\n});\n\n//# sourceURL=webpack://nipplejs/./src/index.js?");

/***/ }),

/***/ "./src/manager.js":
/*!************************!*\
  !*** ./src/manager.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _collection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./collection */ \"./src/collection.js\");\n/* harmony import */ var _super__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./super */ \"./src/super.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\n\n ///////////////////////\n///     MANAGER     ///\n///////////////////////\n\nfunction Manager(options) {\n  var self = this;\n  self.ids = {};\n  self.index = 0;\n  self.collections = [];\n  self.scroll = _utils__WEBPACK_IMPORTED_MODULE_2__[\"getScroll\"]();\n  self.config(options);\n  self.prepareCollections(); // Listen for resize, to reposition every joysticks\n\n  var resizeHandler = function resizeHandler() {\n    var pos;\n    self.collections.forEach(function (collection) {\n      collection.forEach(function (nipple) {\n        pos = nipple.el.getBoundingClientRect();\n        nipple.position = {\n          x: self.scroll.x + pos.left,\n          y: self.scroll.y + pos.top\n        };\n      });\n    });\n  };\n\n  _utils__WEBPACK_IMPORTED_MODULE_2__[\"bindEvt\"](window, 'resize', function () {\n    _utils__WEBPACK_IMPORTED_MODULE_2__[\"throttle\"](resizeHandler);\n  }); // Listen for scrolls, so we have a global scroll value\n  // without having to request it all the time.\n\n  var scrollHandler = function scrollHandler() {\n    self.scroll = _utils__WEBPACK_IMPORTED_MODULE_2__[\"getScroll\"]();\n  };\n\n  _utils__WEBPACK_IMPORTED_MODULE_2__[\"bindEvt\"](window, 'scroll', function () {\n    _utils__WEBPACK_IMPORTED_MODULE_2__[\"throttle\"](scrollHandler);\n  });\n  return self.collections;\n}\n\nManager.prototype = new _super__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\nManager.constructor = Manager;\n\nManager.prototype.prepareCollections = function () {\n  var self = this; // Public API Preparation.\n\n  self.collections.create = self.create.bind(self); // Listen to anything\n\n  self.collections.on = self.on.bind(self); // Unbind general events\n\n  self.collections.off = self.off.bind(self); // Destroy everything\n\n  self.collections.destroy = self.destroy.bind(self); // Get any nipple\n\n  self.collections.get = function (id) {\n    var nipple; // Use .every() to break the loop as soon as found.\n\n    self.collections.every(function (collection) {\n      nipple = collection.get(id);\n      return nipple ? false : true;\n    });\n    return nipple;\n  };\n};\n\nManager.prototype.create = function (options) {\n  return this.createCollection(options);\n}; // Collection Factory\n\n\nManager.prototype.createCollection = function (options) {\n  var self = this;\n  var collection = new _collection__WEBPACK_IMPORTED_MODULE_0__[\"default\"](self, options);\n  self.bindCollection(collection);\n  self.collections.push(collection);\n  return collection;\n};\n\nManager.prototype.bindCollection = function (collection) {\n  var self = this;\n  var type; // Bubble up identified events.\n\n  var handler = function handler(evt, data) {\n    // Identify the event type with the nipple's identifier.\n    type = evt.type + ' ' + data.id + ':' + evt.type;\n    self.trigger(type, data);\n  }; // When it gets destroyed we clean.\n\n\n  collection.on('destroyed', self.onDestroyed.bind(self)); // Other events that will get bubbled up.\n\n  collection.on('shown hidden rested dir plain', handler);\n  collection.on('dir:up dir:right dir:down dir:left', handler);\n  collection.on('plain:up plain:right plain:down plain:left', handler);\n};\n\nManager.prototype.bindDocument = function () {\n  var self = this; // Bind only if not already binded\n\n  if (!self.binded) {\n    self.bindEvt(document, 'move').bindEvt(document, 'end');\n    self.binded = true;\n  }\n};\n\nManager.prototype.unbindDocument = function (force) {\n  var self = this; // If there are no touch left\n  // unbind the document.\n\n  if (!Object.keys(self.ids).length || force === true) {\n    self.unbindEvt(document, 'move').unbindEvt(document, 'end');\n    self.binded = false;\n  }\n};\n\nManager.prototype.getIdentifier = function (evt) {\n  var id; // If no event, simple increment\n\n  if (!evt) {\n    id = this.index;\n  } else {\n    // Extract identifier from event object.\n    // Unavailable in mouse events so replaced by latest increment.\n    id = evt.identifier === undefined ? evt.pointerId : evt.identifier;\n\n    if (id === undefined) {\n      id = this.latest || 0;\n    }\n  }\n\n  if (this.ids[id] === undefined) {\n    this.ids[id] = this.index;\n    this.index += 1;\n  } // Keep the latest id used in case we're using an unidentified mouseEvent\n\n\n  this.latest = id;\n  return this.ids[id];\n};\n\nManager.prototype.removeIdentifier = function (identifier) {\n  var removed = {};\n\n  for (var id in this.ids) {\n    if (this.ids[id] === identifier) {\n      removed.id = id;\n      removed.identifier = this.ids[id];\n      delete this.ids[id];\n      break;\n    }\n  }\n\n  return removed;\n};\n\nManager.prototype.onmove = function (evt) {\n  var self = this;\n  self.onAny('move', evt);\n  return false;\n};\n\nManager.prototype.onend = function (evt) {\n  var self = this;\n  self.onAny('end', evt);\n  return false;\n};\n\nManager.prototype.oncancel = function (evt) {\n  var self = this;\n  self.onAny('end', evt);\n  return false;\n};\n\nManager.prototype.onAny = function (which, evt) {\n  var self = this;\n  var id;\n  var processFn = 'processOn' + which.charAt(0).toUpperCase() + which.slice(1);\n  evt = _utils__WEBPACK_IMPORTED_MODULE_2__[\"prepareEvent\"](evt);\n\n  var processColl = function processColl(e, id, coll) {\n    if (coll.ids.indexOf(id) >= 0) {\n      coll[processFn](e); // Mark the event to avoid cleaning it later.\n\n      e._found_ = true;\n    }\n  };\n\n  var processEvt = function processEvt(e) {\n    id = self.getIdentifier(e);\n    _utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"](self.collections, processColl.bind(null, e, id)); // If the event isn't handled by any collection,\n    // we need to clean its identifier.\n\n    if (!e._found_) {\n      self.removeIdentifier(id);\n    }\n  };\n\n  _utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"](evt, processEvt);\n  return false;\n}; // Cleanly destroy the manager\n\n\nManager.prototype.destroy = function () {\n  var self = this;\n  self.unbindDocument(true);\n  self.ids = {};\n  self.index = 0;\n  self.collections.forEach(function (collection) {\n    collection.destroy();\n  });\n  self.off();\n}; // When a collection gets destroyed\n// we clean behind.\n\n\nManager.prototype.onDestroyed = function (evt, coll) {\n  var self = this;\n\n  if (self.collections.indexOf(coll) < 0) {\n    return false;\n  }\n\n  self.collections.splice(self.collections.indexOf(coll), 1);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Manager);\n\n//# sourceURL=webpack://nipplejs/./src/manager.js?");

/***/ }),

/***/ "./src/nipple.js":
/*!***********************!*\
  !*** ./src/nipple.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _super__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./super */ \"./src/super.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\n ///////////////////////\n///   THE NIPPLE    ///\n///////////////////////\n\nfunction Nipple(collection, options) {\n  this.identifier = options.identifier;\n  this.position = options.position;\n  this.frontPosition = options.frontPosition;\n  this.collection = collection; // Defaults\n\n  this.defaults = {\n    size: 100,\n    threshold: 0.1,\n    color: 'white',\n    fadeTime: 250,\n    dataOnly: false,\n    restJoystick: true,\n    restOpacity: 0.5,\n    mode: 'dynamic',\n    zone: document.body,\n    lockX: false,\n    lockY: false,\n    shape: 'circle'\n  };\n  this.config(options); // Overwrites\n\n  if (this.options.mode === 'dynamic') {\n    this.options.restOpacity = 0;\n  }\n\n  this.id = Nipple.id;\n  Nipple.id += 1;\n  this.buildEl().stylize(); // Nipple's API.\n\n  this.instance = {\n    el: this.ui.el,\n    on: this.on.bind(this),\n    off: this.off.bind(this),\n    show: this.show.bind(this),\n    hide: this.hide.bind(this),\n    add: this.addToDom.bind(this),\n    remove: this.removeFromDom.bind(this),\n    destroy: this.destroy.bind(this),\n    setPosition: this.setPosition.bind(this),\n    resetDirection: this.resetDirection.bind(this),\n    computeDirection: this.computeDirection.bind(this),\n    trigger: this.trigger.bind(this),\n    position: this.position,\n    frontPosition: this.frontPosition,\n    ui: this.ui,\n    identifier: this.identifier,\n    id: this.id,\n    options: this.options\n  };\n  return this.instance;\n}\n\nNipple.prototype = new _super__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\nNipple.constructor = Nipple;\nNipple.id = 0; // Build the dom element of the Nipple instance.\n\nNipple.prototype.buildEl = function (options) {\n  this.ui = {};\n\n  if (this.options.dataOnly) {\n    return this;\n  }\n\n  this.ui.el = document.createElement('div');\n  this.ui.back = document.createElement('div');\n  this.ui.front = document.createElement('div');\n  this.ui.el.className = 'nipple collection_' + this.collection.id;\n  this.ui.back.className = 'back';\n  this.ui.front.className = 'front';\n  this.ui.el.setAttribute('id', 'nipple_' + this.collection.id + '_' + this.id);\n  this.ui.el.appendChild(this.ui.back);\n  this.ui.el.appendChild(this.ui.front);\n  return this;\n}; // Apply CSS to the Nipple instance.\n\n\nNipple.prototype.stylize = function () {\n  if (this.options.dataOnly) {\n    return this;\n  }\n\n  var animTime = this.options.fadeTime + 'ms';\n  var borderStyle = _utils__WEBPACK_IMPORTED_MODULE_1__[\"getVendorStyle\"]('borderRadius', '50%');\n  var transitStyle = _utils__WEBPACK_IMPORTED_MODULE_1__[\"getTransitionStyle\"]('transition', 'opacity', animTime);\n  var styles = {};\n  styles.el = {\n    position: 'absolute',\n    opacity: this.options.restOpacity,\n    display: 'block',\n    'zIndex': 999\n  };\n  styles.back = {\n    position: 'absolute',\n    display: 'block',\n    width: this.options.size + 'px',\n    height: this.options.size + 'px',\n    marginLeft: -this.options.size / 2 + 'px',\n    marginTop: -this.options.size / 2 + 'px',\n    background: this.options.color,\n    'opacity': '.5'\n  };\n  styles.front = {\n    width: this.options.size / 2 + 'px',\n    height: this.options.size / 2 + 'px',\n    position: 'absolute',\n    display: 'block',\n    marginLeft: -this.options.size / 4 + 'px',\n    marginTop: -this.options.size / 4 + 'px',\n    background: this.options.color,\n    'opacity': '.5',\n    transform: 'translate(0px, 0px)'\n  };\n  _utils__WEBPACK_IMPORTED_MODULE_1__[\"extend\"](styles.el, transitStyle);\n\n  if (this.options.shape === 'circle') {\n    _utils__WEBPACK_IMPORTED_MODULE_1__[\"extend\"](styles.back, borderStyle);\n  }\n\n  _utils__WEBPACK_IMPORTED_MODULE_1__[\"extend\"](styles.front, borderStyle);\n  this.applyStyles(styles);\n  return this;\n};\n\nNipple.prototype.applyStyles = function (styles) {\n  // Apply styles\n  for (var i in this.ui) {\n    if (this.ui.hasOwnProperty(i)) {\n      for (var j in styles[i]) {\n        this.ui[i].style[j] = styles[i][j];\n      }\n    }\n  }\n\n  return this;\n}; // Inject the Nipple instance into DOM.\n\n\nNipple.prototype.addToDom = function () {\n  // We're not adding it if we're dataOnly or already in dom.\n  if (this.options.dataOnly || document.body.contains(this.ui.el)) {\n    return this;\n  }\n\n  this.options.zone.appendChild(this.ui.el);\n  return this;\n}; // Remove the Nipple instance from DOM.\n\n\nNipple.prototype.removeFromDom = function () {\n  if (this.options.dataOnly || !document.body.contains(this.ui.el)) {\n    return this;\n  }\n\n  this.options.zone.removeChild(this.ui.el);\n  return this;\n}; // Entirely destroy this nipple\n\n\nNipple.prototype.destroy = function () {\n  clearTimeout(this.removeTimeout);\n  clearTimeout(this.showTimeout);\n  clearTimeout(this.restTimeout);\n  this.trigger('destroyed', this.instance);\n  this.removeFromDom();\n  this.off();\n}; // Fade in the Nipple instance.\n\n\nNipple.prototype.show = function (cb) {\n  var self = this;\n\n  if (self.options.dataOnly) {\n    return self;\n  }\n\n  clearTimeout(self.removeTimeout);\n  clearTimeout(self.showTimeout);\n  clearTimeout(self.restTimeout);\n  self.addToDom();\n  self.restCallback();\n  setTimeout(function () {\n    self.ui.el.style.opacity = 1;\n  }, 0);\n  self.showTimeout = setTimeout(function () {\n    self.trigger('shown', self.instance);\n\n    if (typeof cb === 'function') {\n      cb.call(this);\n    }\n  }, self.options.fadeTime);\n  return self;\n}; // Fade out the Nipple instance.\n\n\nNipple.prototype.hide = function (cb) {\n  var self = this;\n\n  if (self.options.dataOnly) {\n    return self;\n  }\n\n  self.ui.el.style.opacity = self.options.restOpacity;\n  clearTimeout(self.removeTimeout);\n  clearTimeout(self.showTimeout);\n  clearTimeout(self.restTimeout);\n  self.removeTimeout = setTimeout(function () {\n    var display = self.options.mode === 'dynamic' ? 'none' : 'block';\n    self.ui.el.style.display = display;\n\n    if (typeof cb === 'function') {\n      cb.call(self);\n    }\n\n    self.trigger('hidden', self.instance);\n  }, self.options.fadeTime);\n\n  if (self.options.restJoystick) {\n    var rest = self.options.restJoystick;\n    var newPosition = {};\n    newPosition.x = rest === true || rest.x !== false ? 0 : self.instance.frontPosition.x;\n    newPosition.y = rest === true || rest.y !== false ? 0 : self.instance.frontPosition.y;\n    self.setPosition(cb, newPosition);\n  }\n\n  return self;\n}; // Set the nipple to the specified position\n\n\nNipple.prototype.setPosition = function (cb, position) {\n  var self = this;\n  self.frontPosition = {\n    x: position.x,\n    y: position.y\n  };\n  var animTime = self.options.fadeTime + 'ms';\n  var transitStyle = {};\n  transitStyle.front = _utils__WEBPACK_IMPORTED_MODULE_1__[\"getTransitionStyle\"]('transition', ['transform'], animTime);\n  var styles = {\n    front: {}\n  };\n  styles.front = {\n    transform: 'translate(' + self.frontPosition.x + 'px,' + self.frontPosition.y + 'px)'\n  };\n  self.applyStyles(transitStyle);\n  self.applyStyles(styles);\n  self.restTimeout = setTimeout(function () {\n    if (typeof cb === 'function') {\n      cb.call(self);\n    }\n\n    self.restCallback();\n  }, self.options.fadeTime);\n};\n\nNipple.prototype.restCallback = function () {\n  var self = this;\n  var transitStyle = {};\n  transitStyle.front = _utils__WEBPACK_IMPORTED_MODULE_1__[\"getTransitionStyle\"]('transition', 'none', '');\n  self.applyStyles(transitStyle);\n  self.trigger('rested', self.instance);\n};\n\nNipple.prototype.resetDirection = function () {\n  // Fully rebuild the object to let the iteration possible.\n  this.direction = {\n    x: false,\n    y: false,\n    angle: false\n  };\n};\n\nNipple.prototype.computeDirection = function (obj) {\n  var rAngle = obj.angle.radian;\n  var angle45 = Math.PI / 4;\n  var angle90 = Math.PI / 2;\n  var direction, directionX, directionY; // Angular direction\n  //     \\  UP /\n  //      \\   /\n  // LEFT       RIGHT\n  //      /   \\\n  //     /DOWN \\\n  //\n\n  if (rAngle > angle45 && rAngle < angle45 * 3 && !obj.lockX) {\n    direction = 'up';\n  } else if (rAngle > -angle45 && rAngle <= angle45 && !obj.lockY) {\n    direction = 'left';\n  } else if (rAngle > -angle45 * 3 && rAngle <= -angle45 && !obj.lockX) {\n    direction = 'down';\n  } else if (!obj.lockY) {\n    direction = 'right';\n  } // Plain direction\n  //    UP                 |\n  // _______               | RIGHT\n  //                  LEFT |\n  //   DOWN                |\n\n\n  if (!obj.lockY) {\n    if (rAngle > -angle90 && rAngle < angle90) {\n      directionX = 'left';\n    } else {\n      directionX = 'right';\n    }\n  }\n\n  if (!obj.lockX) {\n    if (rAngle > 0) {\n      directionY = 'up';\n    } else {\n      directionY = 'down';\n    }\n  }\n\n  if (obj.force > this.options.threshold) {\n    var oldDirection = {};\n    var i;\n\n    for (i in this.direction) {\n      if (this.direction.hasOwnProperty(i)) {\n        oldDirection[i] = this.direction[i];\n      }\n    }\n\n    var same = {};\n    this.direction = {\n      x: directionX,\n      y: directionY,\n      angle: direction\n    };\n    obj.direction = this.direction;\n\n    for (i in oldDirection) {\n      if (oldDirection[i] === this.direction[i]) {\n        same[i] = true;\n      }\n    } // If all 3 directions are the same, we don't trigger anything.\n\n\n    if (same.x && same.y && same.angle) {\n      return obj;\n    }\n\n    if (!same.x || !same.y) {\n      this.trigger('plain', obj);\n    }\n\n    if (!same.x) {\n      this.trigger('plain:' + directionX, obj);\n    }\n\n    if (!same.y) {\n      this.trigger('plain:' + directionY, obj);\n    }\n\n    if (!same.angle) {\n      this.trigger('dir dir:' + direction, obj);\n    }\n  } else {\n    this.resetDirection();\n  }\n\n  return obj;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Nipple);\n\n//# sourceURL=webpack://nipplejs/./src/nipple.js?");

/***/ }),

/***/ "./src/super.js":
/*!**********************!*\
  !*** ./src/super.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n///////////////////////\n///   SUPER CLASS   ///\n///////////////////////\n // Constants\n\nvar isTouch = !!('ontouchstart' in window);\nvar isPointer = window.PointerEvent ? true : false;\nvar isMSPointer = window.MSPointerEvent ? true : false;\nvar events = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    end: 'touchend, touchcancel'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    end: 'mouseup'\n  },\n  pointer: {\n    start: 'pointerdown',\n    move: 'pointermove',\n    end: 'pointerup, pointercancel'\n  },\n  MSPointer: {\n    start: 'MSPointerDown',\n    move: 'MSPointerMove',\n    end: 'MSPointerUp'\n  }\n};\nvar toBind;\nvar secondBind = {};\n\nif (isPointer) {\n  toBind = events.pointer;\n} else if (isMSPointer) {\n  toBind = events.MSPointer;\n} else if (isTouch) {\n  toBind = events.touch;\n  secondBind = events.mouse;\n} else {\n  toBind = events.mouse;\n}\n\nfunction Super() {} // Basic event system.\n\n\nSuper.prototype.on = function (arg, cb) {\n  var self = this;\n  var types = arg.split(/[ ,]+/g);\n  var type;\n  self._handlers_ = self._handlers_ || {};\n\n  for (var i = 0; i < types.length; i += 1) {\n    type = types[i];\n    self._handlers_[type] = self._handlers_[type] || [];\n\n    self._handlers_[type].push(cb);\n  }\n\n  return self;\n};\n\nSuper.prototype.off = function (type, cb) {\n  var self = this;\n  self._handlers_ = self._handlers_ || {};\n\n  if (type === undefined) {\n    self._handlers_ = {};\n  } else if (cb === undefined) {\n    self._handlers_[type] = null;\n  } else if (self._handlers_[type] && self._handlers_[type].indexOf(cb) >= 0) {\n    self._handlers_[type].splice(self._handlers_[type].indexOf(cb), 1);\n  }\n\n  return self;\n};\n\nSuper.prototype.trigger = function (arg, data) {\n  var self = this;\n  var types = arg.split(/[ ,]+/g);\n  var type;\n  self._handlers_ = self._handlers_ || {};\n\n  for (var i = 0; i < types.length; i += 1) {\n    type = types[i];\n\n    if (self._handlers_[type] && self._handlers_[type].length) {\n      self._handlers_[type].forEach(function (handler) {\n        handler.call(self, {\n          type: type,\n          target: self\n        }, data);\n      });\n    }\n  }\n}; // Configuration\n\n\nSuper.prototype.config = function (options) {\n  var self = this;\n  self.options = self.defaults || {};\n\n  if (options) {\n    self.options = _utils__WEBPACK_IMPORTED_MODULE_0__[\"safeExtend\"](self.options, options);\n  }\n}; // Bind internal events.\n\n\nSuper.prototype.bindEvt = function (el, type) {\n  var self = this;\n  self._domHandlers_ = self._domHandlers_ || {};\n\n  self._domHandlers_[type] = function () {\n    if (typeof self['on' + type] === 'function') {\n      self['on' + type].apply(self, arguments);\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn('[WARNING] : Missing \"on' + type + '\" handler.');\n    }\n  };\n\n  _utils__WEBPACK_IMPORTED_MODULE_0__[\"bindEvt\"](el, toBind[type], self._domHandlers_[type]);\n\n  if (secondBind[type]) {\n    // Support for both touch and mouse at the same time.\n    _utils__WEBPACK_IMPORTED_MODULE_0__[\"bindEvt\"](el, secondBind[type], self._domHandlers_[type]);\n  }\n\n  return self;\n}; // Unbind dom events.\n\n\nSuper.prototype.unbindEvt = function (el, type) {\n  var self = this;\n  self._domHandlers_ = self._domHandlers_ || {};\n  _utils__WEBPACK_IMPORTED_MODULE_0__[\"unbindEvt\"](el, toBind[type], self._domHandlers_[type]);\n\n  if (secondBind[type]) {\n    // Support for both touch and mouse at the same time.\n    _utils__WEBPACK_IMPORTED_MODULE_0__[\"unbindEvt\"](el, secondBind[type], self._domHandlers_[type]);\n  }\n\n  delete self._domHandlers_[type];\n  return this;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Super);\n\n//# sourceURL=webpack://nipplejs/./src/super.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! exports provided: distance, angle, findCoord, radians, degrees, isPressed, throttle, bindEvt, unbindEvt, trigger, prepareEvent, getScroll, applyPosition, getTransitionStyle, getVendorStyle, configStylePropertyObject, extend, safeExtend, map, clamp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle\", function() { return angle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findCoord\", function() { return findCoord; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"radians\", function() { return radians; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"degrees\", function() { return degrees; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPressed\", function() { return isPressed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"throttle\", function() { return throttle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bindEvt\", function() { return bindEvt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unbindEvt\", function() { return unbindEvt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trigger\", function() { return trigger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"prepareEvent\", function() { return prepareEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScroll\", function() { return getScroll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyPosition\", function() { return applyPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTransitionStyle\", function() { return getTransitionStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getVendorStyle\", function() { return getVendorStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"configStylePropertyObject\", function() { return configStylePropertyObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extend\", function() { return extend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"safeExtend\", function() { return safeExtend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"map\", function() { return map; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clamp\", function() { return clamp; });\n///////////////////////\n///      UTILS      ///\n///////////////////////\nvar distance = function distance(p1, p2) {\n  var dx = p2.x - p1.x;\n  var dy = p2.y - p1.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\nvar angle = function angle(p1, p2) {\n  var dx = p2.x - p1.x;\n  var dy = p2.y - p1.y;\n  return degrees(Math.atan2(dy, dx));\n};\nvar findCoord = function findCoord(p, d, a) {\n  var b = {\n    x: 0,\n    y: 0\n  };\n  a = radians(a);\n  b.x = p.x - d * Math.cos(a);\n  b.y = p.y - d * Math.sin(a);\n  return b;\n};\nvar radians = function radians(a) {\n  return a * (Math.PI / 180);\n};\nvar degrees = function degrees(a) {\n  return a * (180 / Math.PI);\n};\nvar isPressed = function isPressed(evt) {\n  if (isNaN(evt.buttons)) {\n    return evt.pressure !== 0;\n  }\n\n  return evt.buttons !== 0;\n};\nvar timers = new Map();\nvar throttle = function throttle(cb) {\n  if (timers.has(cb)) {\n    clearTimeout(timers.get(cb));\n  }\n\n  timers.set(cb, setTimeout(cb, 100));\n};\nvar bindEvt = function bindEvt(el, arg, handler) {\n  var types = arg.split(/[ ,]+/g);\n  var type;\n\n  for (var i = 0; i < types.length; i += 1) {\n    type = types[i];\n\n    if (el.addEventListener) {\n      el.addEventListener(type, handler, false);\n    } else if (el.attachEvent) {\n      el.attachEvent(type, handler);\n    }\n  }\n};\nvar unbindEvt = function unbindEvt(el, arg, handler) {\n  var types = arg.split(/[ ,]+/g);\n  var type;\n\n  for (var i = 0; i < types.length; i += 1) {\n    type = types[i];\n\n    if (el.removeEventListener) {\n      el.removeEventListener(type, handler);\n    } else if (el.detachEvent) {\n      el.detachEvent(type, handler);\n    }\n  }\n};\nvar trigger = function trigger(el, type, data) {\n  var evt = new CustomEvent(type, data);\n  el.dispatchEvent(evt);\n};\nvar prepareEvent = function prepareEvent(evt) {\n  evt.preventDefault();\n  return evt.type.match(/^touch/) ? evt.changedTouches : evt;\n};\nvar getScroll = function getScroll() {\n  var x = window.pageXOffset !== undefined ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;\n  var y = window.pageYOffset !== undefined ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n  return {\n    x: x,\n    y: y\n  };\n};\nvar applyPosition = function applyPosition(el, pos) {\n  if (pos.top || pos.right || pos.bottom || pos.left) {\n    el.style.top = pos.top;\n    el.style.right = pos.right;\n    el.style.bottom = pos.bottom;\n    el.style.left = pos.left;\n  } else {\n    el.style.left = pos.x + 'px';\n    el.style.top = pos.y + 'px';\n  }\n};\nvar getTransitionStyle = function getTransitionStyle(property, values, time) {\n  var obj = configStylePropertyObject(property);\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (typeof values === 'string') {\n        obj[i] = values + ' ' + time;\n      } else {\n        var st = '';\n\n        for (var j = 0, max = values.length; j < max; j += 1) {\n          st += values[j] + ' ' + time + ', ';\n        }\n\n        obj[i] = st.slice(0, -2);\n      }\n    }\n  }\n\n  return obj;\n};\nvar getVendorStyle = function getVendorStyle(property, value) {\n  var obj = configStylePropertyObject(property);\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      obj[i] = value;\n    }\n  }\n\n  return obj;\n};\nvar configStylePropertyObject = function configStylePropertyObject(prop) {\n  var obj = {};\n  obj[prop] = '';\n  var vendors = ['webkit', 'Moz', 'o'];\n  vendors.forEach(function (vendor) {\n    obj[vendor + prop.charAt(0).toUpperCase() + prop.slice(1)] = '';\n  });\n  return obj;\n};\nvar extend = function extend(objA, objB) {\n  for (var i in objB) {\n    if (objB.hasOwnProperty(i)) {\n      objA[i] = objB[i];\n    }\n  }\n\n  return objA;\n}; // Overwrite only what's already present\n\nvar safeExtend = function safeExtend(objA, objB) {\n  var obj = {};\n\n  for (var i in objA) {\n    if (objA.hasOwnProperty(i) && objB.hasOwnProperty(i)) {\n      obj[i] = objB[i];\n    } else if (objA.hasOwnProperty(i)) {\n      obj[i] = objA[i];\n    }\n  }\n\n  return obj;\n}; // Map for array or unique item.\n\nvar map = function map(ar, fn) {\n  if (ar.length) {\n    for (var i = 0, max = ar.length; i < max; i += 1) {\n      fn(ar[i]);\n    }\n  } else {\n    fn(ar);\n  }\n}; // Clamp position within the range\n\nvar clamp = function clamp(pos, nipplePos, size) {\n  return {\n    //                          left-clamping        right-clamping\n    x: Math.min(Math.max(pos.x, nipplePos.x - size), nipplePos.x + size),\n    //                          top-clamping         bottom-clamping\n    y: Math.min(Math.max(pos.y, nipplePos.y - size), nipplePos.y + size)\n  };\n};\n\n//# sourceURL=webpack://nipplejs/./src/utils.js?");

/***/ })

/******/ })["default"];
});